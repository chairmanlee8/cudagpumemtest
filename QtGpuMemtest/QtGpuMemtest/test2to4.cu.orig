#include "gputests.h"

__global__ void 
kernel_move_inv_write(char* _ptr, char* end_ptr, unsigned int pattern)
{
    unsigned int i;
    unsigned int* ptr = (unsigned int*) (_ptr + blockIdx.x*BLOCKSIZE);
    if (ptr >= (unsigned int*) end_ptr) {
	return;
    }
    
    for (i = 0;i < BLOCKSIZE/sizeof(unsigned int); i++){
	ptr[i] = pattern;
    }
    
    return;    
}


__global__ void 
kernel_move_inv_readwrite(char* _ptr, char* end_ptr, unsigned int p1, unsigned int p2, unsigned int* err,
			  unsigned long* err_addr, unsigned long* err_expect, unsigned long* err_current, unsigned long* err_second_read)
{
    unsigned int i;
    unsigned int* ptr = (unsigned int*) (_ptr + blockIdx.x*BLOCKSIZE);
    if (ptr >= (unsigned int*) end_ptr) {
	return;
    }
    
    for (i = 0;i < BLOCKSIZE/sizeof(unsigned int); i++){
	if (ptr[i] != p1){
	    RECORD_ERR(err, &ptr[i], p1, ptr[i]);
	}
	ptr[i] = p2;
	
    }
    
    return;    
}


__global__ void 
kernel_move_inv_read(char* _ptr, char* end_ptr,  unsigned int pattern, unsigned int* err, 
		     unsigned long* err_addr, unsigned long* err_expect, unsigned long* err_current, unsigned long* err_second_read )
{
    unsigned int i;
    unsigned int* ptr = (unsigned int*) (_ptr + blockIdx.x*BLOCKSIZE);
    if (ptr >= (unsigned int*) end_ptr) {
	return;
    }
    
    for (i = 0;i < BLOCKSIZE/sizeof(unsigned int); i++){
	if (ptr[i] != pattern){
	    RECORD_ERR(err, &ptr[i], pattern, ptr[i]);
	}
    }
    
    return;    
}


unsigned int
move_inv_test(char* ptr, unsigned int tot_num_blocks, unsigned int p1, unsigned p2, unsigned int* err_count, unsigned long* err_addr,
		  unsigned long* err_expect, unsigned long* err_current, unsigned long* err_second_read, bool *term)
{
    
    unsigned int i;
    unsigned int err = 0;
    char* end_ptr = ptr + tot_num_blocks* BLOCKSIZE;
    
    for (i= 0;i < tot_num_blocks; i+= GRIDSIZE){
		if(*term == true) break;
	dim3 grid;
	grid.x= GRIDSIZE;
	kernel_move_inv_write<<<grid, 1>>>(ptr + i*BLOCKSIZE, end_ptr, p1); SYNC_CUERR;
	//SHOW_PROGRESS("move_inv_write", i, tot_num_blocks);	
    }
    
    
    for (i=0;i < tot_num_blocks; i+= GRIDSIZE){
		if(*term == true) break;
	dim3 grid;
	grid.x= GRIDSIZE;
	kernel_move_inv_readwrite<<<grid, 1>>>(ptr + i*BLOCKSIZE, end_ptr, p1, p2, err_count, err_addr, err_expect, err_current, err_second_read); SYNC_CUERR;
	//err += error_checking("move_inv_readwrite",  i);	
	//SHOW_PROGRESS("move_inv_readwrite", i, tot_num_blocks);	
    }
    
    for (i=0;i < tot_num_blocks; i+= GRIDSIZE){
		if(*term == true) break;
	dim3 grid;
	grid.x= GRIDSIZE;
	kernel_move_inv_read<<<grid, 1>>>(ptr + i*BLOCKSIZE, end_ptr, p2, err_count, err_addr, err_expect, err_current, err_second_read); SYNC_CUERR;
	//err += error_checking("move_inv_read",  i);	
	//SHOW_PROGRESS("move_inv_read", i, tot_num_blocks);	
    }
        
    return err;
    
}

int 
test2(char* ptr, unsigned int tot_num_blocks, int num_iterations, unsigned int* err, unsigned long* err_addr,
		  unsigned long* err_expect, unsigned long* err_current, unsigned long* err_second_read, bool *term)
{
    unsigned int p1 = 0;
    unsigned int p2 = ~p1;

    
    //DEBUG_PRINTF("Test2: Moving inversions test, with pattern 0x%x and 0x%x\n", p1, p2);
    move_inv_test(ptr, tot_num_blocks, p1, p2, err, err_addr, err_expect, err_current, err_second_read, term);
    //DEBUG_PRINTF("Test2: Moving inversions test, with pattern 0x%x and 0x%x\n", p2, p1);    
    move_inv_test(ptr, tot_num_blocks, p2, p1, err, err_addr, err_expect, err_current, err_second_read, term);

	return cudaSuccess;

}

int 
test3(char* ptr, unsigned int tot_num_blocks, int num_iterations, unsigned int* err, unsigned long* err_addr,
		  unsigned long* err_expect, unsigned long* err_current, unsigned long* err_second_read, bool *term)
{
    unsigned int p0=0x80;
    unsigned int p1 = p0 | (p0 << 8) | (p0 << 16) | (p0 << 24);
    unsigned int p2 = ~p1;
    
    //DEBUG_PRINTF("Test3: Moving inversions test, with pattern 0x%x and 0x%x\n", p1, p2);
    move_inv_test(ptr, tot_num_blocks, p1, p2, err, err_addr, err_expect, err_current, err_second_read, term);
    //DEBUG_PRINTF("Test3: Moving inversions test, with pattern 0x%x and 0x%x\n", p2, p1);    
    move_inv_test(ptr, tot_num_blocks, p2, p1, err, err_addr, err_expect, err_current, err_second_read, term);

	return cudaSuccess;

}

/************************************************************************************
 * Test 4 [Moving inversions, random pattern]
 * Test 4 uses the same algorithm as test 1 but the data pattern is a
 * random number and it's complement. This test is particularly effective
 * in finding difficult to detect data sensitive errors. A total of 60
 * patterns are used. The random number sequence is different with each pass
 * so multiple passes increase effectiveness.
 *
 *************************************************************************************/

unsigned int 
get_random_num(void)
{
    /*struct timeval t0;
    if (gettimeofday(&t0, NULL) !=0){
	fprintf(stderr, "ERROR: gettimeofday() failed\n");
	exit(ERR_GENERAL);
    }*/
    
    //unsigned int seed= (unsigned int)t0.tv_sec;
	unsigned int seed = (unsigned int) GetTickCount();
    srand(seed);
    
    return rand();
}

int 
test4(char* ptr, unsigned int tot_num_blocks, int num_iterations, unsigned int* err_count, unsigned long* err_addr,
		  unsigned long* err_expect, unsigned long* err_current, unsigned long* err_second_read, bool *term)
{
    unsigned int p1;
    //if (global_pattern == 0){
	p1 = get_random_num();
    //}else{
	//p1 = global_pattern;
    //}
    
    unsigned int p2 = ~p1;
    unsigned int err = 0;
    unsigned int iteration = 0;
 
    //DEBUG_PRINTF("Test4: Moving inversions test, with random pattern 0x%x and 0x%x\n", p1, p2);

 repeat:
    err += move_inv_test(ptr, tot_num_blocks, p1, p2, err_count, err_addr, err_expect, err_current, err_second_read, term);
    
    if (err == 0 && iteration == 0){
	return cudaSuccess;
    }
    if (iteration < MAX_ITERATION){	
		//if(*term == true) break;
	//PRINTF("%dth repeating test4 because there are %d errors found in last run\n", iteration, err);	
	iteration++;
	err = 0;
	if(*term == false) goto repeat;
    }

	return cudaSuccess;
}